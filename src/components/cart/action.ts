"use server";

import { payload } from "@/payload";
import { Product, UsersCart } from "@/payload-types";
import { headers as nextHeaders, cookies } from "next/headers";

type CartItem = NonNullable<UsersCart["items"]>[0];
const COOKIE_CART_KEY = "cart";

// -- Cookie Handling
export const getCookieCart = async () => {
    console.log("Getting cookie cart");
    try {
        const cart = (await cookies()).get(COOKIE_CART_KEY)?.value;
        console.log("Got cookie cart: ", cart);
        return cart ? JSON.parse(cart) : (await setCookieCart());
    } catch (error) {
        console.error("Error getting cookie cart:", error);
        return null;
    }
};

export const setCookieCart = async (cart?: UsersCart) => {
    const userCart = cart || { items: [], total: 0 };
    console.log("Setting cookie cart: ", userCart);
    try {
        console.log("Set cookie cart: ", cart);
        return (await cookies()).set(COOKIE_CART_KEY, JSON.stringify(userCart), {
            maxAge: 7 * 24 * 60 * 60,
            secure: true,
            sameSite: "strict",
        });
        
    } catch (error) {
        console.error("Error setting cookie cart:", error);
        return null;
    }
};

// -- Fetch Cart or Create New Cart
export const getCart = async (): Promise<UsersCart | null> => {
    const headers = await nextHeaders();
    const { user } = await payload.auth({ headers });
    if (!user) {
        return (await getCookieCart())
    }

    const { docs: cart } = await payload.find({
        collection: "users-cart",
        where: {
            user: { equals: user?.id },
        },
    });

    if (!cart.length) {
        return createCart(user.id);
    }

    return cart[0];
};

// -- Create Cart for Logged-in User
export const createCart = async (userId: number): Promise<UsersCart | null> => {
    try {
        return await payload.create({
            collection: "users-cart",
            data: {
                user: userId,
            },
        });
    } catch (error) {
        console.error("Error creating cart:", error);
        return null;
    }
};

// -- Add Item to Cart
export const addItem = async ({
    selectedVariantId,
    product,
    quantity = 1,
}: AddItem): Promise<UsersCart | null> => {
    try {
        const currentCart = await getCart();
        if (!currentCart) return null;

        const existingItems = currentCart.items || [];
        const existingItemIndex = existingItems.findIndex(
            (item) => item.variantId === selectedVariantId
        );

        let updatedItems;
        if (existingItemIndex > -1) {
            updatedItems = existingItems.map((item, index) => {
                if (index === existingItemIndex) {
                    const updatedQuantity = (item.quantity || 0) + quantity;
                    return { ...item, quantity: updatedQuantity };
                }
                return item;
            });
        } else {
            const selectedVariant = product.variantInventory?.find(
                (variant) => variant.id === selectedVariantId
            );
            if (!selectedVariant?.id) return null;

            const newItem: CartItem = {
                id: "", // Will be generated by payload
                quantity,
                variantId: selectedVariant.id,
                product: product,
                subTotal: selectedVariant.price! * quantity,
                
            };
            updatedItems = [...existingItems, newItem];
        }

        const updatedCart = {
            ...currentCart,
            items: updatedItems,
            total: updatedItems?.reduce(
                (acc, item) => acc + (item.subTotal || 0),
                0
            ) || 0,
        };
        console.log("-----------------------------------Updated Cart-----------------------------------");
        console.dir(updatedCart);
        const headers = await nextHeaders();
        const { user } = await payload.auth({ headers });
        if (user) {
            await payload.update({
                collection: "users-cart",
                id: currentCart.id,
                data: updatedCart,
            });
        }

        await setCookieCart(updatedCart);
        return updatedCart;
    } catch (err) {
        console.error("Error adding item: ", err);
        return null;
    }
};

// -- Remove Item from Cart
export const removeItem = async ({
    itemId,
    removeCompletely,
}: RemoveItem): Promise<UsersCart | null> => {
    try {
        const currentCart = await getCart();
        if (!currentCart) return null;

        const existingItems = currentCart.items ?? [];

        let updatedItems;
        if (removeCompletely) {
            updatedItems = existingItems.filter(
                (cartItem) => cartItem.id !== itemId
            );
        } else {
            updatedItems = existingItems.flatMap((cartItem) => {
                if (cartItem.id === itemId) {
                    const updatedQuantity = (cartItem.quantity || 1) - 1;

                    if (updatedQuantity <= 0) return [];

                    return [
                        {
                            ...cartItem,
                            quantity: updatedQuantity,
                        },
                    ];
                }
                return [cartItem];
            });
        }

        const updatedCart = {
            ...currentCart,
            items: updatedItems,
            total: updatedItems.reduce(
                (acc, item) => acc + (item.subTotal || 0),
                0
            ),
        };

        const headers = await nextHeaders();
        const { user } = await payload.auth({ headers });
        if (user) {
            await payload.update({
                collection: "users-cart",
                id: currentCart.id,
                data: updatedCart,
            });
        }

        await setCookieCart(updatedCart);
        return updatedCart;
    } catch (err) {
        console.error("Error removing item: ", err);
        return null;
    }
};

type AddItem = {
    selectedVariantId: string;
    product: Product;
    quantity?: number;
};

type RemoveItem = {
    itemId: string;
    removeCompletely?: boolean;
};
