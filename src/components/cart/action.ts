"use server";

import { payload } from "@/payload";
import { Product, UsersCart } from "@/payload-types";
import { headers as nextHeaders, cookies } from "next/headers";

type CartItem = NonNullable<UsersCart["items"]>[0];

export const getCart = async (): Promise<UsersCart | null> => {
  const headers = await nextHeaders();
  const { user } = await payload.auth({ headers });
  if(!user) return null;
  const { docs: cart } = await payload.find({
    collection: "users-cart",
    where: {
      user: {
        equals: user?.id,
      },
    },
  });
  const [usersCart] = cart;
  if(!usersCart) {
    return await createCart();
  }
  return usersCart;
};

type AddItem = {
  currentCart: UsersCart;
  selectedVariantId: string;
  product: Product;
  quantity?: number;
};

export const addItem = async ({ currentCart, selectedVariantId, product, quantity = 1 }: AddItem): Promise<UsersCart> => {
  const existingItems = currentCart.items || [];
  const existingItemIndex = existingItems.findIndex(
    (item) => item.variantId === selectedVariantId
  );

  let updatedItems;

  if (existingItemIndex > -1) {
    updatedItems = existingItems.map((item, index) => {
      if (index === existingItemIndex) {
        const updatedQuantity = (item.quantity || 0) + quantity;
        return {
          ...item,
          quantity: updatedQuantity,
        };
      }
      return item;
    });
  } else {
    const selectedVariant = product.variantInventory?.find((variant) => variant.id === selectedVariantId);
    if (!selectedVariant?.id) return currentCart;

    const newItem: CartItem = {
      id: '', // Will be generated by payload
      quantity,
      variantId: selectedVariant.id,
      product: product,
    };
    updatedItems = [...existingItems, newItem];
  }

  const updatedCart = {
    ...currentCart,
    items: updatedItems,
    total: updatedItems.reduce((acc, item) => acc + (item.subTotal || 0), 0)
  };

  const headers = await nextHeaders();
  const { user } = await payload.auth({ headers });
  if (user) {
    await payload.update({
      collection: "users-cart",
      id: currentCart.id,
      data: updatedCart,
    });
  }

  return updatedCart;
};

type RemoveItem = {
  previousData: UsersCart;
  itemId: string;
  removeCompletely?: boolean;
};

export const removeItem = async ({ previousData, itemId, removeCompletely }: RemoveItem): Promise<UsersCart> => {
  const existingItems = previousData.items ?? [];

  let updatedItems;
  if (removeCompletely) {
    updatedItems = existingItems.filter((cartItem) => cartItem.id !== itemId);
  } else {
    updatedItems = existingItems.flatMap((cartItem) => {
      if (cartItem.id === itemId) {
        const updatedQuantity = (cartItem.quantity || 1) - 1;

        if (updatedQuantity <= 0) return [];

        return [
          {
            ...cartItem,
            quantity: updatedQuantity,
          },
        ];
      }
      return [cartItem];
    });
  }

  const updatedCart = {
    ...previousData,
    items: updatedItems,
    total: updatedItems.reduce((acc, item) => acc + (item.subTotal || 0), 0)
  };

  const headers = await nextHeaders();
  const { user } = await payload.auth({ headers });
  if (user) {
    await payload.update({
      collection: "users-cart",
      id: previousData.id,
      data: updatedCart,
    });
  }

  return updatedCart;
};

export const createCart = async () => {
  const headers = await nextHeaders();
  const { user } = await payload.auth({ headers });
  if(!user) return null;
  try {
    return await payload.create({
      collection: "users-cart",
      data: {
        user: user.id,
      },
    });
  } catch (error) {
    console.error("Error creating cart:", error);
    return null
  }
};
