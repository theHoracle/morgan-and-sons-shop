"use server";

import { payload } from "@/payload";
import { Product, UsersCart } from "@/payload-types";
import { headers as nextHeaders, cookies } from "next/headers";

type CartItem = NonNullable<UsersCart["items"]>[0];

const COOKIE_CART_KEY = "cart";

export const getCookieCart = async (): Promise<UsersCart | null> => {
    try {
        const cart = (await cookies()).get(COOKIE_CART_KEY)?.value;
        return cart ? JSON.parse(cart) : null;
    } catch (error) {
        console.error("Error getting cookie cart:", error);
        return null;
    }
};

export const setCookieCart = async (cart: UsersCart) => {
    try {
        (await cookies()).set(COOKIE_CART_KEY, JSON.stringify(cart), { maxAge: 7 * 24 * 60 * 60, secure: true, sameSite: 'strict' });
    } catch (error) {
        console.error("Error setting cookie cart:", error);
    }
};

export const getCart = async (): Promise<UsersCart | null> => {
    const headers = await nextHeaders();
    const { user } = await payload.auth({ headers });
    if (!user) {
        const usersCart = await getCookieCart();
        return usersCart
    }
    const { docs: cart } = await payload.find({
        collection: "users-cart",
        where: {
            user: {
                equals: user?.id,
            },
        },
    });
    const [usersCart] = cart;
    if (!usersCart) {
        return await createCart();
    }
    return usersCart;
};

export const createCart = async () => {
    const headers = await nextHeaders();
    const { user } = await payload.auth({ headers });
    if (!user) return null;
    try {
        return await payload.create({
            collection: "users-cart",
            data: {
                user: user.id,
            },
        });
    } catch (error) {
        console.error("Error creating cart:", error);
        return null;
    }
};

export const addItem = async ({ currentCart, selectedVariantId, product, quantity = 1 }: AddItem): Promise<void> => {
    try {
    const existingItems = currentCart.items || [];
    const existingItemIndex = existingItems.findIndex(
        (item) => item.variantId === selectedVariantId
    );

    let updatedItems;

    if (existingItemIndex > -1) {
        updatedItems = existingItems.map((item, index) => {
            if (index === existingItemIndex) {
                const updatedQuantity = (item.quantity || 0) + quantity;
                return {
                    ...item,
                    quantity: updatedQuantity,
                };
            }
            return item;
        });
    } else {
        const selectedVariant = product.variantInventory?.find((variant) => variant.id === selectedVariantId);
        if (!selectedVariant?.id) return;

        const newItem: CartItem = {
            id: '', // Will be generated by payload
            quantity,
            variantId: selectedVariant.id,
            product: product,
            subTotal: selectedVariant.price! * quantity,
        };
        updatedItems = [...existingItems, newItem];
    }

    const updatedCart = {
        ...currentCart,
        items: updatedItems,
        total: updatedItems.reduce((acc, item) => acc + (item.subTotal || 0), 0)
    };

    const headers = await nextHeaders();
    const { user } = await payload.auth({ headers });
    if (user) {
        await payload.update({
            collection: "users-cart",
            id: currentCart.id,
            data: updatedCart,
        });
    }
    await setCookieCart(updatedCart);
    } catch(err) {
        console.log('Error adding item: ', err)
    }
};

export const removeItem = async ({ previousData, itemId, removeCompletely }: RemoveItem) => {
    try {
    const existingItems = previousData.items ?? [];

    let updatedItems;
    if (removeCompletely) {
        updatedItems = existingItems.filter((cartItem) => cartItem.id !== itemId);
    } else {
        updatedItems = existingItems.flatMap((cartItem) => {
            if (cartItem.id === itemId) {
                const updatedQuantity = (cartItem.quantity || 1) - 1;

                if (updatedQuantity <= 0) return [];

                return [
                    {
                        ...cartItem,
                        quantity: updatedQuantity,
                    },
                ];
            }
            return [cartItem];
        });
    }

    const updatedCart = {
        ...previousData,
        items: updatedItems,
        total: updatedItems.reduce((acc, item) => acc + (item.subTotal || 0), 0)
    };

    const headers = await nextHeaders();
    const { user } = await payload.auth({ headers });
    if (user) {
        await payload.update({
            collection: "users-cart",
            id: previousData.id,
            data: updatedCart,
        });
    }

    await setCookieCart(updatedCart);
    } catch(err) {
        console.log('Error removing item: ', err)
    }

};

type AddItem = {
    currentCart: UsersCart;
    selectedVariantId: string;
    product: Product;
    quantity?: number;
};

type RemoveItem = {
    previousData: UsersCart;
    itemId: string;
    removeCompletely?: boolean;
};
