"use server";

import { getServerSideUser } from "@/lib/session";
import { payload } from "@/payload";
import { Product, UsersCart } from "@/payload-types";
import { cookies } from "next/headers";


type CartItem = NonNullable<UsersCart["items"]>[0];
const COOKIE_CART_KEY = "USER_CART_ID";

// -- Cookie Handling
export const getCookieCart = async () => {
    console.log("Getting cookie cart");
    const cartId = (await cookies()).get(COOKIE_CART_KEY)?.value;
    return cartId ? cartId : null;
};

export const setCookieCart = async (cartId: string | number) => {
    console.log("Setting cookie cart: ", cartId);
    (await cookies()).set(COOKIE_CART_KEY, cartId.toString());
};

const getCartById = async (cartId: string) => (
    await (payload.findByID({
        collection: "users-cart",
        id: cartId,
    }) ?? createCart())
)

// -- Fetch Cart or Create New Cart
export const getCart = async () => {
    const nextCookies = await cookies();
    const { user } = await getServerSideUser(nextCookies)
    console.log("IS it actually user: ", user)
    // if no user, check for cookie cart. If no cookie cart, create a new cart
    if (!user) {
        const cartId = await getCookieCart()
        if (!cartId) {
            const newCart = await createCart()
            await setCookieCart(newCart.id)
            return newCart
        }
        return getCartById(cartId)
    }
    const { docs: carts } = await payload.find({
        collection: "users-cart",
        where: {
            user: { equals: user?.id },
            and: [ { cartStatus: { equals: "awaitingCheckout" } } ]
        },
    });
    const [cart] = carts
    if(!cart) return await createCart(user?.id)
    return cart;
};


// -- Create Cart
export const createCart = async (userId?: number) => {
        const cart = await payload.create({
            collection: "users-cart",
            data: {
                user: userId,
                items: [],
                total: 0,
            },
        });
        return cart;
};

// -- Add Item to Cart
export const addItem = async ({
    selectedVariantId,
    product,
    quantity = 1,
}: AddItem) => {
    try {
        const currentCart = await getCart();
        if (!currentCart) return;
        const existingItems = currentCart.items || [];
        
        const existingItemIndex = existingItems.findIndex(
            (item) => item.variantId === selectedVariantId
        );

        let updatedItems;
        const selectedVariant = product.variantInventory?.find(
            (variant) => variant.id === selectedVariantId
        );
        if (!selectedVariant?.id) return null;

        if (existingItemIndex > -1) {
            updatedItems = existingItems.map((item, index) => {
                if (index === existingItemIndex) {
                    const updatedQuantity = item.quantity + quantity;
                    return { 
                        ...item, 
                        quantity: updatedQuantity,
                        subTotal: (selectedVariant?.price ?? product.price) *  (item.quantity + quantity),
                     };
                }
                return item;
            });
        } else {
            
            const newItem: CartItem = {
                id: ``, // or Will be generated by payload
                quantity,
                variantId: selectedVariant.id,
                product: product,
                subTotal: (selectedVariant.price ?? product.price) * quantity,
            };
            updatedItems = [...existingItems, newItem];
        }

        const updatedCart = {
            ...currentCart,
            items: updatedItems,
        };

        await payload.update({
                collection: "users-cart",
                id: currentCart.id,
                data: updatedCart,
            }); 
    } catch (err) {
        console.error("Error adding item: ", err);
    }
};

// -- Remove Item from Cart
export const removeItem = async ({
    itemId,
    removeCompletely,
}: RemoveItem) => {
    try {
        const currentCart = await getCart();
        if (!currentCart) return;

        const existingItems = currentCart.items ?? [];

        let updatedItems;
        if (removeCompletely) {
            updatedItems = existingItems.filter(
                (cartItem) => cartItem.id !== itemId
            );
        } else {
            updatedItems = existingItems.flatMap((cartItem) => {
                const singlePrice = (cartItem.subTotal ?? 0) / cartItem.quantity;
                   if (cartItem.id === itemId) {
                    const updatedQuantity = cartItem.quantity - 1;
                    if (updatedQuantity <= 0) return [];
                    return [
                        {
                            ...cartItem,
                            quantity: updatedQuantity,
                            subTotal: singlePrice * updatedQuantity
                        }
                    ];
                }
                return [cartItem];
            });
        }

        const updatedCart = {
            ...currentCart,
            items: updatedItems,
        };
        // update cart
        await payload.update({
            collection: "users-cart",
            id: currentCart.id,
            data: updatedCart,
        });
    } catch (err) {
        console.error("Error removing item: ", err);
    }
};

type AddItem = {
    selectedVariantId: string;
    product: Product;
    quantity?: number;
};

type RemoveItem = {
    itemId: string;
    removeCompletely?: boolean;
};


export const mergeUsersCart = async ({ userId }: {userId: number}) => {
    // get guest cart
    const cookieCartId = await getCookieCart()
    if(!cookieCartId) return;

    // get carts
    const [ guestCart, {docs: usersCart} ] = await Promise.all([
        getCartById(cookieCartId),
        payload.find({ collection: "users-cart", 
                where: { 
                    user: { equals: userId },
                    and: [ { cartStatus: { equals: "awaitingCheckout" } } ]
                } })
    ])
    const [userCart] = usersCart
    if(!userCart && guestCart) {
        const cart = await payload.create({
            collection: "users-cart",
            data: {
                user: userId,
                items: guestCart.items,
                total: guestCart.total
            }
        })
        return await Promise.allSettled([
            setCookieCart(cart.id),
            payload.delete({ collection: "users-cart", id: guestCart.id }),
        ]);
        
    }

    if(!guestCart?.items && !userCart.items) return await setCookieCart(userCart.id);
    
    // Merge carts
    const updatedItems = guestCart.items ? [...guestCart.items] : []
    userCart.items?.forEach(userCartItem => {
        const existingItem = updatedItems.find(item => item.variantId === userCartItem.variantId)
        if(existingItem) {
            existingItem.quantity += userCartItem.quantity
        } else {
            updatedItems.push(userCartItem)
        }
    })
    
    return await Promise.allSettled([
        setCookieCart(userCart.id),
        payload.update({ collection: "users-cart", id: userCart.id, data: { items: updatedItems } }),
        payload.delete({ collection: "users-cart", id: guestCart.id }),
    ]) 
}